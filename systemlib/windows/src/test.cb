import std::system
import io
import memory

// TODO: enum
// TODO: enumflags
// TODO: union

func stringEquals(a: []pure uint8, b: []pure uint8) {
    if (a.len != b.len) { return false }

    for (i in 0,a.len) {
        if (a[i] != b[i]) {
            return false
        }
    }

    return true
}

func intToString(value: int, base: int, dest: []uint8) {
    // check that the base if valid
    if (base < 2 || base > 36) { return 0 }

    let result = dest

    let tpl_str = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"

    let tmp_value : int
    let offs : int
    while (value != 0) {
        if (offs >= result.len) {
            offs -= 1
            break
        }
        
        tmp_value = value
        value /= base

        result.ptr[offs] = tpl_str[35 + (tmp_value - value * base)]
        offs += 1
    }

    let ptr:  &uint8 = &result.ptr[offs]
    let ptr1: &uint8 = &result.ptr[0]

    // Apply negative sign
    if (tmp_value < 0) {
        @ptr = '-'
        ptr += 1
    }

    @ptr = '\0'
    ptr -= 1

    let tmp_char : uint8
    while (ptr1 < ptr) {
        tmp_char = @ptr

        @ptr = @ptr1
        ptr -= 1

        @ptr1 = tmp_char
        ptr1 += 1
    }

    return offs
}

func writeInt(handle: rawptr, value: int) {
    let buf : [32]uint8{}
    let dest = []uint8{&buf[0], sizeof(buf)}
    dest.len = intToString(value, 10, dest)
    write(handle, dest)
}

func readFile(filename: []pure uint8): []uint8  {
    let statdata : Stat
    stat(filename, statdata)

    let bufdata = alloc(statdata.size + 1)

    let data = []uint8{nullcast(cast(*uint8)bufdata), statdata.size}
    data[statdata.size] = 0
    
    let handle, err = open(filename, 0, 0)
    if (err != 0) {
        data.len = 0
        return data
    }

    read(handle, data)
    close(handle)

    return data
}

func test_defer() {
    write(getStdoutFd(), "DEFER\n")
    write(getStdoutFd(), "Exit code should be 1440\n")
    exit(1440)
}

func test_file_write() {
    let handle, err = open("file.txt", O_CREATE | O_WRITE, 0)
    write(handle, "HELLO_WORLD")
    close(handle)

    let newhandle, err = open("file.txt", O_READ, 0)
    defer close(newhandle)

    let statdata : Stat
    stat("file.txt", statdata)

    let bufdata = alloc(statdata.size + 1)
    defer free(bufdata)

    let data = []uint8{nullcast(cast(*uint8)bufdata), statdata.size}
    data[statdata.size] = 0

    read(newhandle, data)
    //write(getStdoutFd(), data)
    //write(getStdoutFd(), "\n")

    return stringEquals(data, "HELLO_WORLD")
}

func test_file_move() {
    let filedata = readFile("file.txt")
    defer free(cast(rawptr)filedata.ptr)

    let err = rename("file.txt", "file2.txt")
    if (err != 0) {
        return false
    }
    defer rename("file2.txt", "file.txt")

    let filedata2 = readFile("file2.txt")
    defer free(cast(rawptr)filedata2.ptr)

    return stringEquals(filedata, filedata2)
}

func test_file_copy() {
    let filedata = readFile("file.txt")
    defer free(cast(rawptr)filedata.ptr)

    let err = copy("file.txt", "file_copy.txt")
    if (err != 0) {
        return false
    }
    defer unlink("file_copy.txt")

    let filedata2 = readFile("file_copy.txt")
    defer free(cast(rawptr)filedata2.ptr)

    return stringEquals(filedata, filedata2)
}

func test_file_append() {
    let handle, err = open("file.txt", O_APPEND, 0)
    write(handle, "HELLO_WORLD")
    close(handle)

    let newhandle, err = open("file.txt", O_READ, 0)
    defer close(newhandle)

    let statdata : Stat
    stat("file.txt", statdata)

    let bufdata = alloc(statdata.size)
    defer free(bufdata)

    let data = []uint8{nullcast(cast(*uint8)bufdata), statdata.size - 1}
    data[statdata.size] = 0

    read(newhandle, data)
    //write(getStdoutFd(), data)
    //write(getStdoutFd(), "\n")

    return (stringEquals(data, "HELLO_WORLDHELLO_WORLD"))
}

func test_file_unlink() {
    let s : Stat
    let err = stat("file.txt", s)
    if (err != 0) {
        //write(getStdoutFd(), "ERROR\n")
        return false
    }
    //write(getStdoutFd(), "EXISTS\n")

    err = unlink("file.txt")
    if (err != 0) {
        return false
    }

    err = stat("file.txt", s)
    if (err != 0) {
        return true
    }

    return false
}

func test_alloc_copy() {
    let str = "ALLOC_COPY\n"
    //write(getStdoutFd(), str)

    let m = alloc(str.len + 1)
    defer free(m)

    let ptr = nullcast(cast(*uint8)m)
    for (i in 0,str.len) {
        ptr[i] = str[i]
    }
    ptr[str.len] = 0
    
    //write(getStdoutFd(), []pure uint8{ptr, str.len})
    return (stringEquals([]pure uint8{ptr, str.len}, "ALLOC_COPY\n"))
}

func test_dir_create() {
    let err = mkdir("test_dir_create")
    if (err != 0) {
        return false
    }
    return true
}

func test_dir_remove() {
    let handle, err = open("test_dir_create/testfile.txt", O_CREATE | O_WRITE, 0)
    if (err != 0) {
        return false
    }
    write(handle, "TESTFILE")
    close(handle)

    // Should not be able to remove non-empty dir
    err = remove("test_dir_create")
    if (err == 0) {
        return false
    }

    unlink("test_dir_create/testfile.txt")

    // Should be able to remove empty dir
    err = remove("test_dir_create")
    if (err != 0) {
        return false
    }

    return true
}

func getValues() {
    return "GET_VALUES",48
}

let counter : int
let mutex : MutexHandle

func workerThreadFunc(arg: rawptr) {
    lock(mutex)
    defer unlock(mutex)

    write(getStdoutFd(), "worker_thread: ")
    writeInt(getStdoutFd(), getThreadId())
    write(getStdoutFd(), "\n")

    counter += 1
}

extern(C) func test_main(): int {
    let a,b = getValues()
    write(getStdoutFd(), a)
    if (b == 48) {
        write(getStdoutFd(), ", 48")
    }
    write(getStdoutFd(), "\n")

    defer test_defer()

    if (test_file_write()) {
        write(getStdoutFd(), "test_file_write: OK\n")
    }
    else {
        write(getStdoutFd(), "test_file_write: NOK\n")
    }

    if (test_file_move()) {
        write(getStdoutFd(), "test_file_move: OK\n")
    }
    else {
        write(getStdoutFd(), "test_file_move: NOK\n")
    }

    if (test_file_copy()) {
        write(getStdoutFd(), "test_file_copy: OK\n")
    }
    else {
        write(getStdoutFd(), "test_file_copy: NOK\n")
    }

    if (test_file_append()) {
        write(getStdoutFd(), "test_file_append: OK\n")
    }
    else {
        write(getStdoutFd(), "test_file_append: NOK\n")
    }

    if (test_alloc_copy()) {
        write(getStdoutFd(), "test_alloc_copy: OK\n")
    }
    else {
        write(getStdoutFd(), "test_alloc_copy: NOK\n")
    }

    if (test_file_unlink()) {
        write(getStdoutFd(), "test_file_unlink: OK\n")
    }
    else {
        write(getStdoutFd(), "test_file_unlink: NOK\n")
    }

    if (test_dir_create()) {
        write(getStdoutFd(), "test_dir_create: OK\n")
    }
    else {
        write(getStdoutFd(), "test_dir_create: NOK\n")
    }

    if (test_dir_remove()) {
        write(getStdoutFd(), "test_dir_remove: OK\n")
    }
    else {
        write(getStdoutFd(), "test_dir_remove: NOK\n")
    }

    let c : uint8
    let err = execProcess("C:\\q2dev\\q2tools-220\\x64\\Release\\4rad.exe", "")
    if (err == 0) {
        write(getStdoutFd(), "exec_process: OK\n")
    }
    else {
        write(getStdoutFd(), "exec_process: NOK\n")
        exit(err)
    }

    let mut, merr = createMutex()
    if (merr != 0) {
        exit(1)
    }
    defer destroy(mut)

    mutex = mut

    let th, terr = createThread(workerThreadFunc\{rawptr}, nullptr)
    if (terr != 0) {
        exit(1)
    }

    lock(mutex)

    write(getStdoutFd(), "main_thread: ")
    writeInt(getStdoutFd(), getThreadId())
    write(getStdoutFd(), "\n")

    counter += 1

    unlock(mutex)

    const LIMIT = 20000000
    let i = 0
    while (i < LIMIT) {
        i += 1
    }

    lock(mutex)

    write(getStdoutFd(), "counter: ")
    writeInt(getStdoutFd(), counter)
    write(getStdoutFd(), "\n")

    unlock(mutex)

    join(th)

    return 0
}