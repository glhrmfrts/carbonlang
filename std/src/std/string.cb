import std::mem
import std::rawstring

type string = struct {
    ptr: &uint8
    len: usize
    cap: usize
}

type string = []pure uint8

let MAX_INTEGER_STRING_LEN = 24

func int_to_string(value: int, base: int, dest: &string) {
    // check that the base if valid
    if (base < 2 || base > 36) { return 0 }

    let result = @dest

    let tpl_str = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"

    let tmp_value : int
    let offs : int
    while (value != 0) {
        if (offs >= result.cap) {
            offs -= 1
            break
        }
        
        tmp_value = value
        value /= base

        result.ptr[offs] = tpl_str[35 + (tmp_value - value * base)]
        offs += 1
    }

    let ptr:  &uint8 = &result.ptr[offs]
    let ptr1: &uint8 = &result.ptr[0]

    // Apply negative sign
    if (tmp_value < 0) {
        @ptr = '-'
        ptr += 1
    }

    @ptr = '\0'
    ptr -= 1

    let tmp_char : uint8
    while (ptr1 < ptr) {
        tmp_char = @ptr

        @ptr = @ptr1
        ptr -= 1

        @ptr1 = tmp_char
        ptr1 += 1
    }

    dest.len = offs
    return 0
}

func to_string(i: int, dest: &string) {
    let n = int_to_string(i, 10, dest)
    return n
}

func as_string(c: &pure uint8, dest: &string) {
    @dest = string{ cast(&uint8)c, c->length(), c->length() }
    return 0
}

func as_string(c: []pure uint8, dest: &string) {
    @dest = string{ cast(&uint8)c.ptr, c.len, c.len + 1 }
    return 0
}

func as_string(m: memory) {
    let ptr = nullcast(cast(*uint8)m.ptr)
    return string{ ptr, ptr->length(), m.len }
}

func as_string(buf: []uint8) {
    return string{ buf.ptr, buf.ptr->length(), buf.len }
}

func as_slice(str: &pure string) {
    return []pure uint8{ str.ptr, str.len }
}

func to_string(b: bool, dest: &string) {
    if (b) {
        return "true"->as_string(dest)
    } else {
        return "false"->as_string(dest)
    }
}

func append(a: []pure uint8, result: &string): usize {
    let copylen = a.len
    if (copylen + result.len > result.cap) {
        copylen = (result.cap - result.len)
    }
    copy(cast(rawptr)(result.ptr + result.len), cast(rawptr) a.ptr, copylen)
    result.len += copylen
    return a.len - copylen
}