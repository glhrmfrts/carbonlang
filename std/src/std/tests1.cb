// test stuff

import std::io;
import std::rawstring;
import std::memory as mem;
import std::libc::stdio;
import std::libc::stdlib;

/*
func print_the_char(v: char, d: *char) {
    puts(&v);
}

func longfunc(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int): int {
    return a + b + c + d + e + f + g + h;
}

func test_longfunc() {
    let result = longfunc(1, 2, 3, 4, 5, 6, 7, 8);
    if (result == 36) {
        println("[OK] test_longfunc");
    }
    else {
        println("[NOK] test_longfunc");
    }
}

func test_strcopy_len() {
    let str = "hello";
    let newstr = str.copy;

    if (str.len == newstr.len) {
        println("[OK] test_strcopy_len");
    }
    else {
        println("[NOK] test_strcopy_len");
    }

    mem::dealloc(cast[raw_ptr] newstr);
}

func test_strcopy() {
    let str = "hello";
    let newstr = copy(str);

    if (str[0] == newstr[0] && str[1] == newstr[1] && str[2] == newstr[2] && str[3] == newstr[3] && str[4] == newstr[4]) {
        println("[OK] test_strcopy");
    }
    else {
        println("[NOK] test_strcopy");
    }

    mem::dealloc(cast[raw_ptr] newstr);
}

func test_strcopy_saving() {
    let str = "hello";
    let newstr = copy(str);

    let c1 = str[0] == newstr[0];
    let c2 = str[1] == newstr[1];
    let c3 = str[2] == newstr[2];
    let c4 = str[3] == newstr[3];
    let c5 = str[4] == newstr[4];

    if (c1 && c2 && c3 && c4 && c5) {
        println("[OK] test_strcopy_saving");
    }
    else {
        println("[NOK] test_strcopy_saving");
    }
    
    mem::dealloc(cast[raw_ptr] newstr);
}

func test_while_statement() {
    let str = "hello";
    let newstr = copy(str);

    var i = 0;
    while (i < 5) {
        newstr[i] = 'G';
        i = i + 1;
    }

    //println(newstr);

    if (i < 5) {
        println("asdasd");
    }

    if (equals(newstr, "GGGGG") && !equals(newstr, "foobar")) {
        println("[OK] test_while_statement");
    }
    else {
        println("[NOK] test_while_statement");
    }
    
    mem::dealloc(cast[raw_ptr] newstr);
}

func test_short(): bool {
    println("SHOULD NOT PRINT THIS");
    return true;
}

func test_for_stmt() {
    let newstr = "helloworld".copy;

    for (i in 0, newstr.len) {
        let c = '0' + cast[int8] i;
        newstr[i] = c;
    }
    if (equals(newstr, "0123456789")) {
        //println(newstr);
        println("[OK] test_for_stmt");
    }
    else {
        println("[NOK] test_for_stmt");
    }
    mem::dealloc(cast[raw_ptr] newstr);
}

func test_struct_zeroinit() {
    var a: range[int];
    var b: range[int] = { };

    if ((a.start == 0 && a.end == 0) && (b.start == 0 && b.end == 0)) {
        println("[OK] test_struct_zeroinit");
    }
    else {
        println("[NOK] test_struct_zeroinit");
    }
}

func test_struct_init() {
    let a: range[int] = { 3, 5 };
    let b: range[int] = { 24*7+2, a.end };
    let c = range[int]{ b.start*3*9, b.end*2*2 };
    let d = range[int]{};

    if ((a.start == 3 && a.end == 5) && (b.start == 24*7+2 && b.end == a.end) && (c.start == b.start*3*9 && c.end && b.end*2*2)) {
        println("[OK] test_struct_init");
    }
    else {
        println("[NOK] test_struct_init");
    }
}

func test_tuple_zeroinit() {
    var a: {int, int};
    var b: {raw_string, bool};

    if ((a[0] == 0 && a.second == 0) && (equals(b[0], "") && b[1] == false)) {
        println("[OK] test_tuple_zeroinit");
    }
    else {
        println("[NOK] test_tuple_zeroinit");
    }
}

func test_tuple_init() {
    let a = {3, 4, 5};
    let b = {"nice", "second", false};

    if ((a.first == 3 && a.second == 4 && a.third == 5) && (equals(b[0], "nice") && equals(b[1], "second") && !b[2])) {
        println("[OK] test_tuple_init");
    }
    else {
        println("[NOK] test_tuple_init");
    }
}


func test_array_zeroinit() {
    let a: [16]int;

    if (a[0] == 0 && a[12] == 0) {
        println("[OK] test_array_zeroinit");
    }
    else {
        println("[NOK] test_array_zeroinit");
    }
}

func test_array_init() {
    let a = [3]int{ 1, 2, 3 };

    if (a[0] == 1 && a[1] == 2 && a[2] == 3) {
        println("[OK] test_array_init");
    }
    else {
        println("[NOK] test_array_init");
    }
}


func test_struct_assignment_lvalue() {
    let a: range[usize] = { 3, 5 };
    let b = a;

    if (a.start == b.start && a.end == b.end) {
        println("[OK] test_struct_assignment_lvalue");
    }
    else {
        println("[NOK] test_struct_assignment_lvalue");
    }
}


func sum_range_ptr(r: *range[usize]): usize {
    return r.start + r.end - 1;
}

func sum_range_ptr(r: &range[usize]): usize {
    return r.start + r.end;
}

func sum_range_val(r: range[usize]): usize {
    return r.start + r.end;
}

func sum_range_copy(r: range[usize]): usize {
    let r2 = r;
    return r2.start + r2.end;
}

func test_struct_argument(): {} {
    let a: range[usize] = { 10, 20 };

    let result = sum_range_ptr(&a);
    let valres = sum_range_val(a);
    let cpres  = sum_range_copy(a);

    if (result == 30 && valres == 30 && cpres == 30) {
        println("[OK] test_struct_argument");
    }
    else {
        println("[NOK] test_struct_argument");
    }
}


func make_range(): range[usize] {
    return range[usize]{ 30, 40 };
}

func make_range_with(a: usize, b: usize): range[usize] {
    return range[usize]{ a, b };
}

func make_range_zero_one(): range[usize] {
    return make_range_with(0, 1);
}

func test_struct_return_value(): {} {
    let r = make_range();
    let r2 = make_range_with(570, 600);
    let r3 = make_range_zero_one();

    if (r.start == 30 && r.end == 40 && r2.start == 570 && r2.end == 600 && r3.start == 0 && r3.end == 1) {
        println("[OK] test_struct_return_value");
    }
    else {
        println("[NOK] test_struct_return_value");
    }
}


func test_tuple_assignment_lvalue() {
    let a = {3,4,5};
    let b = a;
    var c = {0,1,2};
    
    c = b;

    if (a[0] == b[0] && a[1] == b[1] && a[2] == b[2]) {
        println("[OK] test_tuple_assignment_lvalue");
    }
    else {
        println("[NOK] test_tuple_assignment_lvalue");
    }
}


func sum_tuple(t: {int, int, int}): int {
    return t[0] + t[1] + t[2];
}

func test_tuple_argument() {
    let a = {3,4,5};
    let ares = sum_tuple(a);
    if (ares == 3+4+5) {
        println("[OK] test_tuple_argument");
    }
    else {
        println("[NOK] test_tuple_argument");
    }
}


func do_stuff(): {raw_string, bool} {
    return "some_status", true;
}

func test_tuple_return_value(): {} {
    let result = do_stuff();

    if (equals(result.first, "some_status") && result.second == true) {
        println("[OK] test_tuple_return_value");
    }
    else {
        println("[NOK] test_tuple_return_value");
    }
}


func test_array_assignment_lvalue() {
    let a = [6]uint{ 3, 5 };
    let b = a;

    if (a[0] == b[0] && a[1] == b[1] && a[2] == b[2]) {
        println("[OK] test_array_assignment_lvalue");
    }
    else {
        println("[NOK] test_array_assignment_lvalue");
    }
}

*/
func sum_array(t: [6]int): int {
    var res = 0;
    for (i in 0, 6) {
        res = res+t[i];
    }
    return res;
}
/*
func test_array_argument() {
    let ares = sum_array([6]int{ 1, 2, 3 });
    if (ares == 1+2+3) {
        println("[OK] test_array_argument");
    }
    else {
        println("[NOK] test_array_argument");
    }
}
*/

func get_array_data(): [6]int {
    return [6]int{ 5, 6, 7 };
}

func test_array_return_value() {
    if (sum_array(get_array_data()) == 5+6+7) {
        println("[OK] test_array_return_value");
    }
    else {
        println("[NOK] test_array_return_value");
    }
}


func get_result(): int { return 2; }

func main(): int {
    //let result = get_result();

    /*
    test_longfunc();
    test_strcopy_len();
    test_strcopy();
    test_strcopy_saving();
    test_while_statement();
    test_for_stmt();
    test_struct_zeroinit();
    test_struct_init();
    test_tuple_zeroinit();
    test_tuple_init();
    test_array_zeroinit();
    test_array_init();
    test_struct_assignment_lvalue();
    test_struct_argument();
    test_struct_return_value();
    test_tuple_assignment_lvalue();
    test_tuple_argument();
    test_tuple_return_value();
    test_array_assignment_lvalue();
    test_array_argument();*/
    test_array_return_value();

    //mem::dealloc(cast[raw_ptr] newtext);
    //return a[0];//result*2;

    //let s = "adqwe";
    //var a: *raw_string = &s;
    //return a[0][0];

    let a = "asdasd000000000";
    let b = "\0\0\n";

    return a[b[get_result()]];
}