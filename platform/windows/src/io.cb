import std::system

extern(C) {
const FILE_BEGIN = 0
const FILE_CURRENT = 1
const FILE_END = 2

func GetCommandLineA(): *pure uint8

func GetStdHandle(nStdHandle: int): int

func WriteFile(handle: int, str: *pure uint8, len: int, written: *int, ov: rawptr)

func ReadFile(
    hFile: int,
    lpBuffer: rawptr,
    nNumberOfBytesToRead: int,
    lpNumberOfBytesRead: *int,
    lpOverlapped: rawptr
): bool

type LPSECURITY_ATTRIBUTES = struct {
    nLength: int
    lpSecurityDescriptor: rawptr
    bInheritHandle: bool
}

func CreateFileA(
    lpFileName: *pure uint8,
    dwDesiredAccess: int,
    dwShareMode: int,
    lpSecurityAttributes: *LPSECURITY_ATTRIBUTES,
    dwCreationDisposition: int,
    dwFlagsAndAttributes: int,
    hTemplateFile: int
): int

func SetFilePointer(
    hFile: int,
    lDistanceToMove: int,
    lpDistanceToMoveHigh: *int,
    dwMoveMethod: int
): int

func CloseHandle(handle: int): int

type BY_HANDLE_FILE_INFORMATION = struct {
    dwFileAttributes: int
    ftCreationTime: int64
    ftLastAccessTime: int64
    ftLastWriteTime: int64
    dwVolumeSerialNumber: int
    nFileSizeHigh: int
    nFileSizeLow: int
    nNumberOfLinks: int
    nFileIndexHigh: int
    nFileIndexLow: int
}

func GetFileInformationByHandle(handle: int, lpFileInformation: &BY_HANDLE_FILE_INFORMATION): bool

func GetLastError(): int
}

extern(carbon, std::system) {

func write(handle: int, data: []pure uint8): isize {
    let written : int
    WriteFile(handle, cast(rawptr)data.ptr, cast(int)data.len, &written, nullptr)
    return written
}

func read(handle: int, data: []uint8): isize {
    let bytes_read : int
    ReadFile(handle, cast(rawptr)data.ptr, cast(int)data.len, &bytes_read, nullptr)
    return bytes_read
}

func open(path: []pure uint8, flags: int, mode: int): {int, error} {
    const GENERIC_READ = 1<<31
    const GENERIC_WRITE = 1<<30
    
    let access = GENERIC_READ
    if ((flags & (O_APPEND | O_WRITE)) != 0) {
        access |= GENERIC_WRITE
    }

    const FILE_SHARE_READ = 1
    const FILE_SHARE_WRITE = 2
    let sharemode = FILE_SHARE_READ | FILE_SHARE_WRITE

    const OPEN_ALWAYS = 4
    const OPEN_EXISTS = 3
    let creation = OPEN_EXISTS
    if ((flags & O_CREATE) != 0) {
        creation = OPEN_ALWAYS
    }

    const FILE_ATTRIBUTE_NORMAL = 128
    let attrs = FILE_ATTRIBUTE_NORMAL

    let err : error
    let handle = CreateFileA(path.ptr, access, sharemode, nullptr, creation, attrs, 0)

    if (handle != 0 && ((flags & O_APPEND) != 0)) {
        SetFilePointer(handle, 0, nullptr, FILE_END)
    }
    
    return handle, err
}

func seek(fd: int, offset: int64, whence: int) {
    // TODO: handle large offset
    SetFilePointer(fd, cast(int)offset, nullptr, whence)
}

func stat(fd: int, buf: &stat_data): error {
    let info : BY_HANDLE_FILE_INFORMATION
    if (!GetFileInformationByHandle(fd, info)) {
        return cast(error)GetLastError()
    }
    buf.size = info.nFileSizeHigh | info.nFileSizeLow
    buf.mtime = info.ftLastWriteTime
    buf.atime = info.ftLastAccessTime
    buf.ctime = info.ftCreationTime
    return 0
}

func stat(filename: []pure uint8, buf: &stat_data): error {
    let handle, err = open(filename, 0, 0)
    if (err != 0) {
        return err
    }
    defer close(handle)

    // TODO: if (let err = stat(handle, buf); err != 0)
    let err = stat(handle, buf)
    if (err != 0) {
        return err
    }
    return 0
}

func close(fd: int): error {
    return CloseHandle(fd)
}

const STD_INPUT_HANDLE = -10
const STD_OUTPUT_HANDLE = -11
const STD_ERROR_HANDLE = -12

func get_stdin_fd(): int {
    return GetStdHandle(STD_INPUT_HANDLE)
}

func get_stdout_fd(): int {
    return GetStdHandle(STD_OUTPUT_HANDLE)
}

func get_stderr_fd(): int {
    return GetStdHandle(STD_ERROR_HANDLE)
}

}
