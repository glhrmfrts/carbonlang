  code_unit{
    main.cb
    decl_list{
      import_decl{ std::alloc alloc}
      import_decl{ std::io}
      import_decl{ std::string}
      type_decl{Field2D = type_expr{struct_type{(var_decl{width: type_expr{int}}, var_decl{height: type_expr{int}}, var_decl{data: type_expr{type_qualifier{reference, int}}})}}}
      type_decl{Automaton = type_expr{struct_type{(var_decl{field: type_expr{Field2D}}, var_decl{new_field: type_expr{Field2D}})}}}
      func_decl{split (var_decl{$cb_agg_ret: }, var_decl{str: }, var_decl{delim: type_expr{char}}):  {
          decl_list{
            var_decl{s = init{type=type_expr{string} 
                {s.data = ""}
                {s.len = cast_expr{ 0}}
                }}}
          stmt_list{
            {{* $cb_agg_ret} = init{type=type_expr{slice_type{[&] type_expr{string}}} 
              {{* $cb_agg_ret}.data = {& s}}
              {{* $cb_agg_ret}.len = cast_expr{ 1}}
              }}
            return{$cb_agg_ret}}}}
      func_decl{map (var_decl{$cb_agg_ret: }, var_decl{str: }, var_decl{f: type_expr{(type_expr{string})type_expr{string}}}):  {
          decl_list{
            var_decl{s = init{type=type_expr{string} 
                {s.data = ""}
                {s.len = cast_expr{ 0}}
                }}}
          stmt_list{
            {{* $cb_agg_ret} = init{type=type_expr{slice_type{[&] type_expr{string}}} 
              {{* $cb_agg_ret}.data = {& s}}
              {{* $cb_agg_ret}.len = cast_expr{ 1}}
              }}
            return{$cb_agg_ret}}}}
      func_decl{filter (var_decl{$cb_agg_ret: }, var_decl{str: }, var_decl{f: type_expr{(type_expr{string})type_expr{bool}}}):  {
          decl_list{
            var_decl{s = init{type=type_expr{string} 
                {s.data = ""}
                {s.len = cast_expr{ 0}}
                }}}
          stmt_list{
            {{* $cb_agg_ret} = init{type=type_expr{slice_type{[&] type_expr{string}}} 
              {{* $cb_agg_ret}.data = {& s}}
              {{* $cb_agg_ret}.len = cast_expr{ 1}}
              }}
            return{$cb_agg_ret}}}}
      func_decl{trim (var_decl{$cb_agg_ret: }, var_decl{str: }):  {
          decl_list{
            var_decl{f: type_expr{char} = 3}}
          stmt_list{
            {{* $cb_agg_ret} = init{type=type_expr{string} 
              {{* $cb_agg_ret}.data = {& f}}
              {{* $cb_agg_ret}.len = cast_expr{ 1}}
              }}
            return{$cb_agg_ret}}}}
      func_decl{append (var_decl{$cb_agg_ret: }, var_decl{str: type_expr{type_qualifier{pointer, string}}}, var_decl{c: type_expr{char}}):  {
          stmt_list{
            {{* $cb_agg_ret} = init{type=type_expr{string} 
              {{* $cb_agg_ret}.data = ""}
              {{* $cb_agg_ret}.len = cast_expr{ 0}}
              }}
            return{$cb_agg_ret}}}}
      func_decl{make_field (var_decl{$cb_agg_ret: }, var_decl{sx: type_expr{int}}, var_decl{sy: type_expr{int}}):  {
          stmt_list{
            {{* $cb_agg_ret} = init{type=type_expr{Field2D} 
              {{* $cb_agg_ret}.width = sx}
              {{* $cb_agg_ret}.height = sy}
              {{* $cb_agg_ret}.data = cast_expr{type_expr{type_qualifier{reference, int}} call{alloc::alloc ({{4 * sx} * sy})}}}
              }}
            return{$cb_agg_ret}}}}
      func_decl{set (var_decl{f: type_expr{type_qualifier{reference, Field2D}}}, var_decl{x: type_expr{int}}, var_decl{y: type_expr{int}}, var_decl{val: type_expr{int}}): type_expr{tuple_type{}} {
          stmt_list{
            {f.data[{{y * f.width} + x}] = val}}}}
      func_decl{get (var_decl{f: type_expr{type_qualifier{pointer, Field2D}}}, var_decl{x: type_expr{int}}, var_decl{y: type_expr{int}}): type_expr{int} {
          stmt_list{
            return{f.data[{{y * f.width} + x}]}}}}
      func_decl{clear (var_decl{f: type_expr{type_qualifier{reference, Field2D}}}): type_expr{tuple_type{}} {
          stmt_list{
            call{alloc::set (cast_expr{type_expr{rawptr} f.data}, 0, {{f.width * f.height} * 4})}}}}
      func_decl{make_automaton (var_decl{$cb_agg_ret: }, var_decl{ftext: }):  {
          decl_list{
            var_decl{$cbT0 = {* ftext}}
            call{split ({& f}, {& $cbT0}, )}
            var_decl{f}
            var_decl{height = cast_expr{type_expr{int} f.len}}
            var_decl{width = 0}}
          stmt_list{
                          (y)              {
                stmt_list{
                  if{{cast_expr{ width} < f.data[y].len} {
                      stmt_list{
                        {width = cast_expr{type_expr{int} f.data[y].len}}}}}}}}
          decl_list{
            call{make_field ({& field}, width, height)}
            var_decl{field}
            call{make_field ({& newfield}, width, height)}
            var_decl{newfield}}
          stmt_list{
                          (y)              {
                stmt_list{
                                      (x)                    {
                      decl_list{
                        if{{{cast_expr{ x} < f.data[y].len} 	 {f.data[y].data[x]  }} {val = 1} else {val = 0}}
                        var_decl{val}}
                      stmt_list{
                        call{set ({& field}, x, y, val)}}}}}}
          stmt_list{
            {{* $cb_agg_ret} = init{type=type_expr{Automaton} 
              {{* $cb_agg_ret}.field = field}
              {{* $cb_agg_ret}.new_field = newfield}
              }}
            return{$cb_agg_ret}}}}
      func_decl{update (var_decl{a: type_expr{type_qualifier{reference, Automaton}}}): type_expr{tuple_type{}} {
          stmt_list{
            call{clear ({& a.new_field})}
                          (y)              {
                stmt_list{
                                      (x)                    {
                      decl_list{
                        var_decl{moore_sum = {{{{{{{{{0 + call{get ({& a.field}, {x - 1}, {y - 1})}} + call{get ({& a.field}, x, {y + 1})}} + call{get ({& a.field}, {x + 1}, {y - 1})}} + call{get ({& a.field}, {x - 1}, y)}} + 0} + call{get ({& a.field}, {x + 1}, y)}} + call{get ({& a.field}, {x - 1}, {y + 1})}} + call{get ({& a.field}, x, {y + 1})}} + call{get ({& a.field}, {x + 1}, {y + 1})}}}
                        var_decl{cell = call{get ({& a.field}, x, y)}}
                        if{{cell  1} if{{{moore_sum  2} 
 {moore_sum  3}} {alive = true} else {alive = false}}
{ = } else if{{moore_sum  3} {alive = true} else {alive = false}}
{ = }}
                        var_decl{alive}}
                      stmt_list{
                        call{set ({& a.new_field}, x, y, if{{alive  false} {$cbT1 = 1} else {$cbT1 = 0}}
$cbT1)}}}}}}
          decl_list{
            var_decl{tmp = a.field}}
          stmt_list{
            {a.field = a.new_field}
            {a.new_field = tmp}}}}
      func_decl{print (var_decl{a: type_expr{type_qualifier{pointer, Automaton}}}): type_expr{tuple_type{}} {
          stmt_list{
                          (y)              {
                decl_list{
                  var_decl{s = init{type=type_expr{string} 
                      {s.data = "    "}
                      {s.len = cast_expr{ 4}}
                      }}}
                stmt_list{
                                      (x)                    {
                      decl_list{
                        var_decl{cell = call{get ({& a.field}, x, y)}}}
                      stmt_list{
                        call{append ({& s}, {& s}, if{{cell  1} {$cbT2 = } else {$cbT2 = }}
$cbT2)}
                        {s = }}}}
                stmt_list{
                  call{println (s.data)}}}}
          stmt_list{
            call{println ("")}}}}
      func_decl{gun (var_decl{$cb_agg_ret: }):  {
          decl_list{
            var_decl{gunfield = "*******************************************
*                                         *
*  A shooting gun:                        *
*                          #              *
*                        # #              *
*              ##      ##            ##   *
*             #   #    ##            ##   *
*  ##        #     #   ##                 *
*  ##        #   # ##    # #              *
*            #     #       #              *
*             #   #                       *
*              ##                         *
*                                         *
*  Tetris Life:                           *
*                                         *
*  ##       ####                          *
*  ##                                     *
*                                         *
*                                         *
*                                         *
*  #         ##                           *
*  ###      ##                            *
*                                         *
*                                         *
*                                         *
*        #                                *
*       ###                               *
*                                         *
*                                         *
*                                         *
*                                         *
*******************************************"}}
          stmt_list{
            var_decl{$cbT3 = init{type=type_expr{string} 
                {$cbT3.data = gunfield}
                {$cbT3.len = gunfield.strlen}
                }}
            call{make_automaton ({& {* $cb_agg_ret}}, {& $cbT3})}
            {{* $cb_agg_ret} = }
            return{$cb_agg_ret}}}}
      func_decl{main (var_decl{args: }): type_expr{int} {
          decl_list{
            call{gun ({& a})}
            var_decl{a}}
          stmt_list{
                          (i)              {
                stmt_list{
                  call{update ({& a})}
                  call{print ({& a})}}}}
          stmt_list{
            return{0}}}}}}  code_unit{
    init.cb
    decl_list{
      import_decl{ std::io}
      import_decl{ std::string}
      import_decl{ std::rawstring}
      import_decl{ std::alloc alloc}
      import_decl{ std::os::windows}
      visibility_specifier{ private decl_list{
          func_decl{init_command_line (var_decl{$cb_agg_ret: }):  {
              decl_list{
                var_decl{cmdline = call{GetCommandLineA ()}}
                var_decl{data = cast_expr{type_expr{type_qualifier{reference, string}} call{alloc::alloc (16)}}}
                var_decl{result = init{type=type_expr{slice_type{[&] type_expr{string}}} 
                    {result.data = data}
                    {result.len = cast_expr{ 1}}
                    }}}
              stmt_list{
                {result.data[0] = init{type=type_expr{string} 
                  {result.data[0].data = cmdline}
                  {result.data[0].len = call{strlen (cmdline)}}
                  }}
                {{* $cb_agg_ret} = result}
                return{$cb_agg_ret}}}}
          func_decl{free_command_line (var_decl{args: }): type_expr{tuple_type{}} {
              stmt_list{
                call{alloc::free (cast_expr{type_expr{rawptr} {* args}.data})}}}}
          linkage_specifier{ extern(C) func_decl{carbon_main (): type_expr{int} {
                decl_list{
                  call{init_command_line ({& args})}
                  var_decl{args}}
                stmt_list{
                  defer{var_decl{$cbT4 = args}
call{free_command_line ({& $cbT4})}}}
                decl_list{
                  import_decl{ main}}
                stmt_list{
                  return{var_decl{$cbT5 = args}
call{main ({& $cbT5})}}}}}}}}}}  code_unit{
    std/alloc.cb
    decl_list{
      import_decl{ std::os::windows}
      func_decl{alloc (var_decl{size: type_expr{usize}}): type_expr{rawptr} {
          stmt_list{
            return{call{HeapAlloc (call{GetProcessHeap ()}, 0, size)}}}}}
      func_decl{free (var_decl{ptr: type_expr{rawptr}}): type_expr{tuple_type{}} {
          stmt_list{
            call{HeapFree (call{GetProcessHeap ()}, 0, ptr)}}}}
      func_decl{copy (var_decl{dest: type_expr{rawptr}}, var_decl{src: type_expr{rawptr}}, var_decl{size: type_expr{usize}}): type_expr{tuple_type{}} {
          decl_list{
            asm{push rdi
push rsi

mov rdi,rcx
mov rsi,rdx
mov rcx,r8
rep movsb

pop rsi
pop rdi
    }}}}
      func_decl{set (var_decl{dest: type_expr{rawptr}}, var_decl{value: type_expr{char}}, var_decl{count: type_expr{usize}}): type_expr{tuple_type{}} {
          decl_list{
            asm{push rdi

mov rdi,rcx
mov rax,rdx
mov rcx,r8
rep stosb

pop rdi
    }}}}}}  code_unit{
    std/configuration.cb
    decl_list{
      type_decl{ConfigurationGroup = type_expr{struct_type{(var_decl{name: type_expr{slice_type{[*] type_expr{char}}}})}}}
      type_decl{Configuration = type_expr{struct_type{(var_decl{first_group: type_expr{type_qualifier{reference, ConfigurationGroup}}})}}}}}  code_unit{
    std/io.cb
    decl_list{
      import_decl{ std::libc::stdio}
      func_decl{println (var_decl{c: type_expr{type_qualifier{pointer, char}}}): type_expr{tuple_type{}} {
          stmt_list{
            call{puts (c)}}}}}}  code_unit{
    std/libc/stdio.cb
    decl_list{
      linkage_specifier{ extern(C) decl_list{
          func_decl{puts (var_decl{c: type_expr{rawstring}}): type_expr{int} }
          func_decl{putc (var_decl{c: type_expr{char}}, var_decl{stream: type_expr{rawptr}}): type_expr{int} }}}}}  code_unit{
    std/libc/stdlib.cb
    decl_list{
      linkage_specifier{ extern(C) decl_list{
          func_decl{exit (var_decl{status: type_expr{int}}): type_expr{tuple_type{}} }
          func_decl{free (var_decl{ptr: type_expr{rawptr}}): type_expr{int} }
          func_decl{malloc (var_decl{size: type_expr{usize}}): type_expr{rawptr} }
          func_decl{rand (): type_expr{int} }
          func_decl{system (var_decl{c: type_expr{rawstring}}): type_expr{int} }}}}}  code_unit{
    std/libc/string.cb
    decl_list{
      linkage_specifier{ extern(C) decl_list{
          func_decl{strlen (var_decl{s: type_expr{rawstring}}): type_expr{usize} }}}}}  code_unit{
    std/os/windows.cb
    decl_list{
      linkage_specifier{ extern(C) decl_list{
          func_decl{HeapAlloc (var_decl{hHeap: type_expr{int}}, var_decl{dwFlags: type_expr{int}}, var_decl{dwBytes: type_expr{usize}}): type_expr{rawptr} }
          func_decl{HeapFree (var_decl{hHeap: type_expr{int}}, var_decl{dwFlags: type_expr{int}}, var_decl{lpMem: type_expr{rawptr}}): type_expr{bool} }
          func_decl{GetProcessHeap (): type_expr{int} }
          func_decl{GetCommandLineA (): type_expr{type_qualifier{reference, char}} }}}}}  code_unit{
    std/rawstring.cb
    decl_list{
      import_decl{ std::alloc alloc}
      func_decl{copy (var_decl{str: type_expr{type_qualifier{pointer, char}}}): type_expr{type_qualifier{pointer, char}} {
          stmt_list{
            return{call{copy (str, call{strlen (str)})}}}}}
      func_decl{copy (var_decl{str: type_expr{type_qualifier{pointer, char}}}, var_decl{size: type_expr{usize}}): type_expr{type_qualifier{pointer, char}} {
          decl_list{
            var_decl{newstr = cast_expr{type_expr{type_qualifier{pointer, char}} call{alloc::alloc ({size + 1})}}}}
          stmt_list{
            call{copy (newstr, str, size)}
            {newstr[size] = 0}
            return{newstr}}}}
      func_decl{copy (var_decl{dest: type_expr{type_qualifier{pointer, char}}}, var_decl{src: type_expr{type_qualifier{pointer, char}}}, var_decl{size: type_expr{usize}}): type_expr{tuple_type{}} {
          stmt_list{
            call{alloc::copy (cast_expr{type_expr{rawptr} dest}, cast_expr{type_expr{rawptr} src}, size)}}}}
      func_decl{set (var_decl{dest: type_expr{type_qualifier{pointer, char}}}, var_decl{value: type_expr{char}}, var_decl{count: type_expr{usize}}): type_expr{tuple_type{}} {
          stmt_list{
            call{alloc::set (cast_expr{type_expr{rawptr} dest}, value, count)}}}}
      func_decl{strlen (var_decl{str: type_expr{type_qualifier{pointer, char}}}): type_expr{usize} {
          decl_list{
            var_decl{c: type_expr{usize} = 0}
            var_decl{p = str}}
          stmt_list{
                          {cast_expr{ {* p}}  0}              {
                stmt_list{
                  {p = {p + 1}}
                  {c = {c + 1}}}}}
          stmt_list{
            return{c}}}}
      func_decl{equals (var_decl{a: type_expr{type_qualifier{pointer, char}}}, var_decl{b: type_expr{type_qualifier{pointer, char}}}): type_expr{bool} {
          stmt_list{
            if{{call{strlen (a)}  call{strlen (b)}} {
                stmt_list{
                  return{false}}}}}
          stmt_list{
                          (i)              {
                stmt_list{
                  if{{a[i]  b[i]} {
                      stmt_list{
                        return{false}}}}}}}
          stmt_list{
            return{true}}}}}}  code_unit{
    std/string.cb
    decl_list{
      type_decl{string = type_expr{slice_type{[*] type_expr{char}}}}}}  code_unit{
    std/tests1.cb
    decl_list{
      func_decl{ok (): type_expr{tuple_type{}} {}}}}  code_unit{
    std/unicode.cb
    decl_list{
      import_decl{ std::alloc alloc}
      import_decl{ std::os::windows}
      type_decl{WideString = type_expr{slice_type{[*] type_expr{int16}}}}
      type_decl{MutableWideString = type_expr{slice_type{[&] type_expr{int16}}}}}}
