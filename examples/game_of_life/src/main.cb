import std::alloc as alloc
import std::io
import std::string
import std::rawstring
//import std::seqs // map, filter, split, trim

// TODO:
//  - parse unified function call with arguments
//  - support non-closure lambdas
//  - support user-defined long strings
//  - time, seq and strings modules

type string = struct {
    auto data: *uint8
    len: usize
}

type dict(K, V) struct {
    type key    K
    type value  V

    auto entries: *dict_entry(K, V)
    len: usize
    cap: usize
}

func set(d: *dict, k: elemtype(d)::key, v: elemtype(d)::value) {
    
}

func make_array(
    _element_type        `T,
    _initial_capacity    cap: int,
    _fill_pointer        fp: int,
    _initial_value       val: T
)
=> Array(T)
{
    auto data = alloc(dict_entry(`K, `V), new_capacity)
    copy(`dict_entry(K, V), data, d.entries, d.len)
    d.entries = data
}

func main(args: []string) {
    auto arr = make_array(
        _element_type=`int,
        _initial_capacity=10
    )

    auto users = make_dict(`string, `User , _hash_func=custom_hash)
    users.set("john", make_user())

    if (auto j = users.get("john"); j) {
        println(j)
    }

    auto old_value = users.remove("john")
    auto old_value = users.remove("john")
    auto old_value = users.remove("joasdas")

    if (users.has_key("john")) {

    }
}

func acquire_ownership(str: string) {
    // string will be freed in this scope
}

type Field2D = struct {
    auto data: *int
    width: int
    height: int
}

type Field2D = struct {
    auto data: *int
    width: int
    height: int
}

type Automaton = struct {
    auto field:      Field2D
    auto new_field:  Field2D
    auto f:          Field2D
}

func split(str: &string, delim: char): []string {
    auto s = string{"", 0}
    return []string{ &s, 1 }
}

func map(str: []string, f: {string} -> string): []string {
    auto s = string{"", 0}
    return []string{ &s, 1 }
}

func filter(str: []string, f: {string} -> bool): []string {
    auto s = string{"", 0}
    return []string{ &s, 1 }
}

func trim(str: &string): string {
    auto f : char = 3
    return string{ &f, 1 }
}

func append(str: &string, c: char): string {
    auto f : char = 3
    return string{ &f, 1 }
}

func make_field(sx: int, sy: int): Field2D {
    return Field2D{
        sx, sy, make_auto(cast(*int) alloc::alloc(sizeof(int)*sx*sy))
    }
}

func set(f: &Field2D, x: int, y: int, val: int) {
    f.data[y * f.width + x] = val
}

func get(f: &Field2D, x: int, y: int): int {
    return f.data[y * f.width + x]
}

func clear(f: &Field2D) {
    alloc::set(cast(rawptr) f.data, 0, f.width*f.height*sizeof(int))
}

func make_automaton(ftext: string): Automaton {
    auto f = ftext.split('\n').map(func(it: string) = it.trim).filter(func(it: string) = it.len > 0)

    auto height = cast(int) f.len
    var width  = 0

    for (y in 0,f.len) {
        if (width < f[y].len) {
            width = cast(int) f[y].len
        }
    }

    auto field    = make_field(width, height)
    auto newfield = make_field(width, height)

    for (y in 0, field.height) {
        for (x in 0, field.width) {
            auto val = x < f[y].len && f[y][x] == '#' then 1 else 0
            field.set(x, y, val)
        }
    }

    auto a = Automaton{}
    a.field = field
    a.new_field = newfield
    return a

    return Automaton{field, newfield}
}

func update(a: &Automaton) {
    a.new_field.clear()
    for (y in 1,a.field.height) {
        for (x in 1,a.field.width) {
            auto moore_sum = (
                0 + a.field.get(x-1, y-1) + a.field.get(x,y+1) + a.field.get(x+1, y-1) +
                a.field.get(x-1, y) + 0 + a.field.get(x+1, y) + a.field.get(x-1, y+1) +
                a.field.get(x,y+1) + a.field.get(x+1, y+1)
            )
            auto cell = a.field.get(x, y)
            auto alive = cell == 1 then (moore_sum == 2 || moore_sum == 3) else moore_sum == 3
            a.new_field.set(x, y, alive then 1 else 0)
        }
    }
    auto tmp = a.field
    a.field = a.new_field
    a.new_field = tmp
}

func print(a: &Automaton) {
    for (y in 1,a.field.height) {
        auto var s = "    "
        for (x in 1,a.field.width) {
            auto cell = a.field.get(x,y)
            s = s.append(cell == 1 then '@' else '.')
        }
        println(s.data)
    }
	println("")
}

func gun(): Automaton {
    auto gunfield = "*******************************************
*                                         *
*  A shooting gun:                        *
*                          #              *
*                        # #              *
*              ##      ##            ##   *
*             #   #    ##            ##   *
*  ##        #     #   ##                 *
*  ##        #   # ##    # #              *
*            #     #       #              *
*             #   #                       *
*              ##                         *
*                                         *
*  Tetris Life:                           *
*                                         *
*  ##       ####                          *
*  ##                                     *
*                                         *
*                                         *
*                                         *
*  #         ##                           *
*  ###      ##                            *
*                                         *
*                                         *
*                                         *
*        #                                *
*       ###                               *
*                                         *
*                                         *
*                                         *
*                                         *
*******************************************"
    return make_automaton(string{ gunfield, gunfield.strlen })
}

func main(args: []string): int {
    auto a = gun()

    for (i in 0,50) {
        //import std::time

        a.update()
        a.print()
        //sleep_ms(100)
    }
    return 0
}