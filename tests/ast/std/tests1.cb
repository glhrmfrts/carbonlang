code_unit{
  std/tests1.cb
  decl_list{
    import_decl{
      identifier{"std::io"}}
    import_decl{
      identifier{"std::rawstring"}}
    import_decl{
      identifier{"std::memory"}
      identifier{"mem"}}
    import_decl{
      identifier{"std::libc::stdio"}}
    import_decl{
      identifier{"std::libc::stdlib"}}
    func_decl{
      identifier{"print_the_char"}
      arg_list(
        var_decl{
          identifier{"v"}
          :type_expr{
            identifier{"char"}}}
        var_decl{
          identifier{"d"}
          :type_expr{
            type_qualifier{pointer,
              identifier{"char"}}}})
compound_stmt{
        stmt_list{
          call_expr{
            identifier{"puts"}
            arg_list(
              unary_expr{
                &
                identifier{"v"}})}}}}
    func_decl{
      identifier{"longfunc"}
      arg_list(
        var_decl{
          identifier{"a"}
          :type_expr{
            identifier{"int"}}}
        var_decl{
          identifier{"b"}
          :type_expr{
            identifier{"int"}}}
        var_decl{
          identifier{"c"}
          :type_expr{
            identifier{"int"}}}
        var_decl{
          identifier{"d"}
          :type_expr{
            identifier{"int"}}}
        var_decl{
          identifier{"e"}
          :type_expr{
            identifier{"int"}}}
        var_decl{
          identifier{"f"}
          :type_expr{
            identifier{"int"}}}
        var_decl{
          identifier{"g"}
          :type_expr{
            identifier{"int"}}}
        var_decl{
          identifier{"h"}
          :type_expr{
            identifier{"int"}}})
      :type_expr{
        identifier{"int"}}
compound_stmt{
        stmt_list{
          return_stmt{
                        binary_expr{
              binary_expr{
                binary_expr{
                  binary_expr{
                    binary_expr{
                      binary_expr{
                        binary_expr{
                          identifier{"a"}
                          +
                          identifier{"b"}}
                        +
                        identifier{"c"}}
                      +
                      identifier{"d"}}
                    +
                    identifier{"e"}}
                  +
                  identifier{"f"}}
                +
                identifier{"g"}}
              +
              identifier{"h"}}}}}}
    func_decl{
      identifier{"test_longfunc"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"result"}
            =call_expr{
              identifier{"longfunc"}
              arg_list(
                int_literal{1}
                int_literal{2}
                int_literal{3}
                int_literal{4}
                int_literal{5}
                int_literal{6}
                int_literal{7}
                int_literal{8})}}}
        stmt_list{
          }}}
    func_decl{
      identifier{"test_strcopy_len"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"str"}
            =string_literal{"hello"}}
          var_decl{
            identifier{"newstr"}
            =}}
        stmt_list{
          }
        stmt_list{
          call_expr{
            identifier{"mem::dealloc"}
            arg_list(
              )}}}}
    func_decl{
      identifier{"test_strcopy"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"str"}
            =string_literal{"hello"}}
          var_decl{
            identifier{"newstr"}
            =call_expr{
              identifier{"copy"}
              arg_list(
                identifier{"str"})}}}
        stmt_list{
          }
        stmt_list{
          call_expr{
            identifier{"mem::dealloc"}
            arg_list(
              )}}}}
    func_decl{
      identifier{"test_strcopy_saving"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"str"}
            =string_literal{"hello"}}
          var_decl{
            identifier{"newstr"}
            =call_expr{
              identifier{"copy"}
              arg_list(
                identifier{"str"})}}
          var_decl{
            identifier{"c1"}
            =binary_expr{
              index_expr{
                identifier{"str"}
                int_literal{0}}
              
              index_expr{
                identifier{"newstr"}
                int_literal{0}}}}
          var_decl{
            identifier{"c2"}
            =binary_expr{
              index_expr{
                identifier{"str"}
                int_literal{1}}
              
              index_expr{
                identifier{"newstr"}
                int_literal{1}}}}
          var_decl{
            identifier{"c3"}
            =binary_expr{
              index_expr{
                identifier{"str"}
                int_literal{2}}
              
              index_expr{
                identifier{"newstr"}
                int_literal{2}}}}
          var_decl{
            identifier{"c4"}
            =binary_expr{
              index_expr{
                identifier{"str"}
                int_literal{3}}
              
              index_expr{
                identifier{"newstr"}
                int_literal{3}}}}
          var_decl{
            identifier{"c5"}
            =binary_expr{
              index_expr{
                identifier{"str"}
                int_literal{4}}
              
              index_expr{
                identifier{"newstr"}
                int_literal{4}}}}}
        stmt_list{
          }
        stmt_list{
          call_expr{
            identifier{"mem::dealloc"}
            arg_list(
              )}}}}
    func_decl{
      identifier{"test_while_statement"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"str"}
            =string_literal{"hello"}}
          var_decl{
            identifier{"newstr"}
            =call_expr{
              identifier{"copy"}
              arg_list(
                identifier{"str"})}}
          var_decl{
            identifier{"i"}
            =int_literal{0}}}
        stmt_list{
          }
        stmt_list{
          }
        stmt_list{
          }
        stmt_list{
          call_expr{
            identifier{"mem::dealloc"}
            arg_list(
              )}}}}
    func_decl{
      identifier{"test_short"}
      arg_list()
      :type_expr{
        identifier{"bool"}}
compound_stmt{
        stmt_list{
          call_expr{
            identifier{"println"}
            arg_list(
              string_literal{"SHOULD NOT PRINT THIS"})}
          return_stmt{
                        bool_literal{true}}}}}
    func_decl{
      identifier{"test_for_stmt"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"newstr"}
            =}}
        stmt_list{
          }
        stmt_list{
          }
        stmt_list{
          call_expr{
            identifier{"mem::dealloc"}
            arg_list(
              )}}}}
    func_decl{
      identifier{"test_struct_zeroinit"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"a"}
            :type_expr{
              }}
          var_decl{
            identifier{"b"}
            :type_expr{
              }
            =init_expr{
              arg_list()}}}
        stmt_list{
          }}}
    func_decl{
      identifier{"test_struct_init"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"a"}
            :type_expr{
              }
            =init_expr{
              arg_list(
                int_literal{3}
                int_literal{5})}}
          var_decl{
            identifier{"b"}
            :type_expr{
              }
            =init_expr{
              arg_list(
                binary_expr{
                  binary_expr{
                    int_literal{24}
                    *
                    int_literal{7}}
                  +
                  int_literal{2}}
                )}}
          var_decl{
            identifier{"c"}
            =init_expr{
              type=type_expr{
                }
              arg_list(
                binary_expr{
                  binary_expr{
                    
                    *
                    int_literal{3}}
                  *
                  int_literal{9}}
                binary_expr{
                  binary_expr{
                    
                    *
                    int_literal{2}}
                  *
                  int_literal{2}})}}
          var_decl{
            identifier{"d"}
            =init_expr{
              type=type_expr{
                }
              arg_list()}}}
        stmt_list{
          }}}
    func_decl{
      identifier{"test_tuple_zeroinit"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"a"}
            :type_expr{
              tuple_type{
                arg_list(
                  type_expr{
                    identifier{"int"}}
                  type_expr{
                    identifier{"int"}})}}}
          var_decl{
            identifier{"b"}
            :type_expr{
              tuple_type{
                arg_list(
                  type_expr{
                    identifier{"raw_string"}}
                  type_expr{
                    identifier{"bool"}})}}}}
        stmt_list{
          }}}
    func_decl{
      identifier{"test_tuple_init"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"a"}
            =init_expr{
              arg_list(
                int_literal{3}
                int_literal{4}
                int_literal{5})}}
          var_decl{
            identifier{"b"}
            =init_expr{
              arg_list(
                string_literal{"nice"}
                string_literal{"second"}
                bool_literal{false})}}}
        stmt_list{
          }}}
    func_decl{
      identifier{"test_struct_assignment_lvalue"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"a"}
            :type_expr{
              }
            =init_expr{
              arg_list(
                int_literal{3}
                int_literal{5})}}
          var_decl{
            identifier{"b"}
            =identifier{"a"}}}
        stmt_list{
          }}}
    func_decl{
      identifier{"sum_range_ptr"}
      arg_list(
        var_decl{
          identifier{"r"}
          :type_expr{
            type_qualifier{pointer,
              }}})
      :type_expr{
        identifier{"usize"}}
compound_stmt{
        stmt_list{
          return_stmt{
                        binary_expr{
              binary_expr{
                
                +
                }
              -
              int_literal{1}}}}}}
    func_decl{
      identifier{"sum_range_ptr"}
      arg_list(
        var_decl{
          identifier{"r"}
          :type_expr{
            type_qualifier{mutable_pointer,
              }}})
      :type_expr{
        identifier{"usize"}}
compound_stmt{
        stmt_list{
          return_stmt{
                        binary_expr{
              
              +
              }}}}}
    func_decl{
      identifier{"sum_range_val"}
      arg_list(
        var_decl{
          identifier{"r"}
          :type_expr{
            }})
      :type_expr{
        identifier{"usize"}}
compound_stmt{
        stmt_list{
          return_stmt{
                        binary_expr{
              
              +
              }}}}}
    func_decl{
      identifier{"sum_range_copy"}
      arg_list(
        var_decl{
          identifier{"r"}
          :type_expr{
            }})
      :type_expr{
        identifier{"usize"}}
compound_stmt{
        decl_list{
          var_decl{
            identifier{"r2"}
            =identifier{"r"}}}
        stmt_list{
          return_stmt{
                        binary_expr{
              
              +
              }}}}}
    func_decl{
      identifier{"test_struct_argument"}
      arg_list()
      :type_expr{
        tuple_type{
}}
compound_stmt{
        decl_list{
          var_decl{
            identifier{"a"}
            :type_expr{
              }
            =init_expr{
              arg_list(
                int_literal{10}
                int_literal{20})}}
          var_decl{
            identifier{"result"}
            =call_expr{
              identifier{"sum_range_ptr"}
              arg_list(
                unary_expr{
                  &
                  identifier{"a"}})}}
          var_decl{
            identifier{"valres"}
            =call_expr{
              identifier{"sum_range_val"}
              arg_list(
                identifier{"a"})}}
          var_decl{
            identifier{"cpres"}
            =call_expr{
              identifier{"sum_range_copy"}
              arg_list(
                identifier{"a"})}}}
        stmt_list{
          }}}
    func_decl{
      identifier{"make_range"}
      arg_list()
      :type_expr{
        }
compound_stmt{
        stmt_list{
          return_stmt{
                        init_expr{
              type=type_expr{
                }
              arg_list(
                int_literal{30}
                int_literal{40})}}}}}
    func_decl{
      identifier{"make_range_with"}
      arg_list(
        var_decl{
          identifier{"a"}
          :type_expr{
            identifier{"usize"}}}
        var_decl{
          identifier{"b"}
          :type_expr{
            identifier{"usize"}}})
      :type_expr{
        }
compound_stmt{
        stmt_list{
          return_stmt{
                        init_expr{
              type=type_expr{
                }
              arg_list(
                identifier{"a"}
                identifier{"b"})}}}}}
    func_decl{
      identifier{"make_range_zero_one"}
      arg_list()
      :type_expr{
        }
compound_stmt{
        stmt_list{
          return_stmt{
                        call_expr{
              identifier{"make_range_with"}
              arg_list(
                int_literal{0}
                int_literal{1})}}}}}
    func_decl{
      identifier{"test_struct_return_value"}
      arg_list()
      :type_expr{
        tuple_type{
}}
compound_stmt{
        decl_list{
          var_decl{
            identifier{"r"}
            =call_expr{
              identifier{"make_range"}
              arg_list()}}
          var_decl{
            identifier{"r2"}
            =call_expr{
              identifier{"make_range_with"}
              arg_list(
                int_literal{570}
                int_literal{600})}}
          var_decl{
            identifier{"r3"}
            =call_expr{
              identifier{"make_range_zero_one"}
              arg_list()}}}
        stmt_list{
          }}}
    func_decl{
      identifier{"test_tuple_assignment_lvalue"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"a"}
            =init_expr{
              arg_list(
                int_literal{3}
                int_literal{4}
                int_literal{5})}}
          var_decl{
            identifier{"b"}
            =identifier{"a"}}
          var_decl{
            identifier{"c"}
            =init_expr{
              arg_list(
                int_literal{0}
                int_literal{1}
                int_literal{2})}}}
        stmt_list{
          binary_expr{
            identifier{"c"}
            =
            identifier{"b"}}
          }}}
    func_decl{
      identifier{"sum_tuple"}
      arg_list(
        var_decl{
          identifier{"t"}
          :type_expr{
            tuple_type{
              arg_list(
                type_expr{
                  identifier{"int"}}
                type_expr{
                  identifier{"int"}}
                type_expr{
                  identifier{"int"}})}}})
      :type_expr{
        identifier{"int"}}
compound_stmt{
        stmt_list{
          return_stmt{
                        binary_expr{
              binary_expr{
                index_expr{
                  identifier{"t"}
                  int_literal{0}}
                +
                index_expr{
                  identifier{"t"}
                  int_literal{1}}}
              +
              index_expr{
                identifier{"t"}
                int_literal{2}}}}}}}
    func_decl{
      identifier{"test_tuple_argument"}
      arg_list()
compound_stmt{
        decl_list{
          var_decl{
            identifier{"a"}
            =init_expr{
              arg_list(
                int_literal{3}
                int_literal{4}
                int_literal{5})}}
          var_decl{
            identifier{"ares"}
            =call_expr{
              identifier{"sum_tuple"}
              arg_list(
                identifier{"a"})}}}
        stmt_list{
          }}}
    func_decl{
      identifier{"do_stuff"}
      arg_list()
      :type_expr{
        tuple_type{
          arg_list(
            type_expr{
              identifier{"raw_string"}}
            type_expr{
              identifier{"bool"}})}}
compound_stmt{
        stmt_list{
          return_stmt{
                        init_expr{
              arg_list(
                string_literal{"some_status"}
                bool_literal{true})}}}}}
    func_decl{
      identifier{"test_tuple_return_value"}
      arg_list()
      :type_expr{
        tuple_type{
}}
compound_stmt{
        decl_list{
          var_decl{
            identifier{"result"}
            =call_expr{
              identifier{"do_stuff"}
              arg_list()}}}
        stmt_list{
          }}}
    func_decl{
      identifier{"get_result"}
      arg_list()
      :type_expr{
        identifier{"int"}}
compound_stmt{
        stmt_list{
          return_stmt{
                        int_literal{2}}}}}
    func_decl{
      identifier{"main"}
      arg_list()
      :type_expr{
        identifier{"int"}}
compound_stmt{
        stmt_list{
          call_expr{
            identifier{"test_longfunc"}
            arg_list()}
          call_expr{
            identifier{"test_strcopy_len"}
            arg_list()}
          call_expr{
            identifier{"test_strcopy"}
            arg_list()}
          call_expr{
            identifier{"test_strcopy_saving"}
            arg_list()}
          call_expr{
            identifier{"test_while_statement"}
            arg_list()}
          call_expr{
            identifier{"test_for_stmt"}
            arg_list()}
          call_expr{
            identifier{"test_struct_zeroinit"}
            arg_list()}
          call_expr{
            identifier{"test_struct_init"}
            arg_list()}
          call_expr{
            identifier{"test_tuple_zeroinit"}
            arg_list()}
          call_expr{
            identifier{"test_tuple_init"}
            arg_list()}
          call_expr{
            identifier{"test_struct_assignment_lvalue"}
            arg_list()}
          call_expr{
            identifier{"test_struct_argument"}
            arg_list()}
          call_expr{
            identifier{"test_struct_return_value"}
            arg_list()}
          call_expr{
            identifier{"test_tuple_assignment_lvalue"}
            arg_list()}
          call_expr{
            identifier{"test_tuple_argument"}
            arg_list()}
          call_expr{
            identifier{"test_tuple_return_value"}
            arg_list()}}
        decl_list{
          var_decl{
            identifier{"a"}
            =string_literal{"asdasd000000000"}}
          var_decl{
            identifier{"b"}
            =string_literal{"  
"}}}
        stmt_list{
          return_stmt{
                        index_expr{
              identifier{"a"}
              index_expr{
                identifier{"b"}
                call_expr{
                  identifier{"get_result"}
                  arg_list()}}}}}}}}}
